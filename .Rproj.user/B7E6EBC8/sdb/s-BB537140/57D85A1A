{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <algorithm>\n\n//using namespace std;\nusing namespace Rcpp;\n\nvoid swapDouble(double& a, double& b) {\n  double temp = a;\n  a = b;\n  b = temp;\n}\nvoid swapDoubleV(std::vector<double>*& a, std::vector<double>*& b) {\n  std::vector<double>* temp = a;\n  a = b;\n  b = temp;\n}\n\n//Fix up for min heap, starting from index k\nvoid fixUpMin(std::vector<double>& heapValue, std::vector<double>& heapWeight, int k) {\n  while (k && heapValue[k / 2] > heapValue[k]) {\n    swapDouble(heapValue[k / 2], heapValue[k]);\n    swapDouble(heapWeight[k / 2], heapWeight[k]);\n    k /= 2;\n  }\n}\n\n//Fix up for max heap, starting from index k\nvoid fixUpMax(std::vector<double>& heapValue, std::vector<double>& heapWeight, int k) {\n  while (k && heapValue[k / 2] < heapValue[k]) {\n    swapDouble(heapValue[k / 2], heapValue[k]);\n    swapDouble(heapWeight[k / 2], heapWeight[k]);\n    k /= 2;\n  }\n}\n\n//Fix down for min heap, starting from index k\nvoid fixDownMin(std::vector<double>& heapValue, std::vector<double>& heapWeight, int k) {\n  int heapSize = heapValue.size();\n  while (2 * k + 1 < heapSize && (heapValue[2 * k + 1] < heapValue[k] || (2 * k + 2 < heapSize && heapValue[2 * k + 2] < heapValue[k]))) {\n    if (2 * k + 2 < heapSize) {\n      if (heapValue[2 * k + 1] < heapValue[2 * k + 2]) {\n        swapDouble(heapValue[2 * k + 1], heapValue[k]);\n        swapDouble(heapWeight[2 * k + 1], heapWeight[k]);\n        k = 2 * k + 1;\n      }\n      else {\n        swapDouble(heapValue[2 * k + 2], heapValue[k]);\n        swapDouble(heapWeight[2 * k + 2], heapWeight[k]);\n        k = 2 * k + 2;\n      }\n    }\n    else {\n      swapDouble(heapValue[2 * k + 1], heapValue[k]);\n      swapDouble(heapWeight[2 * k + 1], heapWeight[k]);\n      k = 2 * k + 1;\n    }\n  }\n}\n\n//Fix down for the max heap, starting from index k\nvoid fixDownMax(std::vector<double>& heapValue, std::vector<double>& heapWeight, int k) {\n  int heapSize = heapValue.size();\n  while (2 * k + 1 < heapSize && (heapValue[2 * k + 1] > heapValue[k] || (2 * k + 2 < heapSize && heapValue[2 * k + 2] > heapValue[k]))) {\n    if (2 * k + 2 < heapSize) {\n      if (heapValue[2 * k + 1] > heapValue[2 * k + 2]) {\n        swapDouble(heapValue[2 * k + 1], heapValue[k]);\n        swapDouble(heapWeight[2 * k + 1], heapWeight[k]);\n        k = 2 * k + 1;\n      }\n      else {\n        swapDouble(heapValue[2 * k + 2], heapValue[k]);\n        swapDouble(heapWeight[2 * k + 2], heapWeight[k]);\n        k = 2 * k + 2;\n      }\n    }\n    else {\n      swapDouble(heapValue[2 * k + 1], heapValue[k]);\n      swapDouble(heapWeight[2 * k + 1], heapWeight[k]);\n      k = 2 * k + 1;\n    }\n  }\n}\n\nvoid addMin(std::vector<double>& heapValue, std::vector<double>& heapWeight, double toAddVal, double toAddWeight) {\n  heapValue.push_back(toAddVal);\n  heapWeight.push_back(toAddWeight);\n  fixUpMin(heapValue, heapWeight, heapValue.size() - 1);\n}\n\nvoid addMax(std::vector<double>& heapValue, std::vector<double>& heapWeight, double toAddVal, double toAddWeight) {\n  heapValue.push_back(toAddVal);\n  heapWeight.push_back(toAddWeight);\n  fixUpMax(heapValue, heapWeight, heapValue.size() - 1);\n}\n\nvoid popMin(std::vector<double>& heapValue, std::vector<double>& heapWeight) {\n  heapValue[0] = heapValue.back();\n  heapWeight[0] = heapWeight.back();\n  heapValue.pop_back();\n  heapWeight.pop_back();\n  fixDownMin(heapValue, heapWeight, 0);\n}\n\nvoid popMax(std::vector<double>& heapValue, std::vector<double>& heapWeight) {\n  heapValue[0] = heapValue.back();\n  heapWeight[0] = heapWeight.back();\n  heapValue.pop_back();\n  heapWeight.pop_back();\n  fixDownMax(heapValue, heapWeight, 0);\n}\n\nvoid addToLevelSet(std::vector<double>& ltHeapValue, std::vector<double>& ltHeapWeight,\n                   std::vector<double>& gtHeapValue, std::vector<double>& gtHeapWeight, double& medVal,\n                   double& medWeight, double& ltWeight, double& gtWeight, double toAddVal, double toAddWeight) {\n  if (toAddVal < medVal) {\n    ltWeight += toAddWeight;\n    addMax(ltHeapValue, ltHeapWeight, toAddVal, toAddWeight);\n  }\n  else {\n    gtWeight += toAddWeight;\n    addMin(gtHeapValue, gtHeapWeight, toAddVal, toAddWeight);\n  }\n  double totalWeight = medWeight + ltWeight + gtWeight;\n  while (ltWeight > totalWeight / 2 || gtWeight > totalWeight / 2) {\n    if (ltWeight > gtWeight) {\n      addMin(gtHeapValue, gtHeapWeight, medVal, medWeight);\n      gtWeight += medWeight;\n      medVal = ltHeapValue[0];\n      medWeight = ltHeapWeight[0];\n      ltWeight -= ltHeapWeight[0];\n      popMax(ltHeapValue, ltHeapWeight);\n    }\n    else {\n      addMax(ltHeapValue, ltHeapWeight, medVal, medWeight);\n      ltWeight += medWeight;\n      medVal = gtHeapValue[0];\n      medWeight = gtHeapWeight[0];\n      gtWeight -= gtHeapWeight[0];\n      popMin(gtHeapValue, gtHeapWeight);\n    }\n  }\n}\n\nvoid merge(std::vector<double>*& ltHeapValue_a, std::vector<double>*& ltHeapWeight_a, std::vector<double>*& gtHeapValue_a, std::vector<double>*& gtHeapWeight_a,\n           double& medVal_a, double& medWeight_a, double& ltWeight_a, double& gtWeight_a, std::vector<double>*& ltHeapValue_b, std::vector<double>*& ltHeapWeight_b,\n           std::vector<double>*& gtHeapValue_b, std::vector<double>*& gtHeapWeight_b, double& medVal_b, double& medWeight_b, double& ltWeight_b, double& gtWeight_b) {\n\n  int a_size = ltHeapValue_a->size() + gtHeapValue_a->size() + 1;\n  int b_size = ltHeapValue_b->size() + gtHeapValue_b->size() + 1;\n\n  if (b_size > a_size) {\n    swapDoubleV(ltHeapValue_a, ltHeapValue_b);\n    swapDoubleV(ltHeapWeight_a, ltHeapWeight_b);\n    swapDoubleV(gtHeapValue_a, gtHeapValue_b);\n    swapDoubleV(gtHeapWeight_a, gtHeapWeight_b);\n    swapDouble(medVal_a, medVal_b);\n    swapDouble(medWeight_a, medWeight_b);\n    swapDouble(ltWeight_a, ltWeight_b);\n    swapDouble(gtWeight_a, gtWeight_b);\n  }\n\n  for (int i = 0; i < int(ltHeapValue_b->size()); ++i) {\n    addToLevelSet(*ltHeapValue_a, *ltHeapWeight_a, *gtHeapValue_a, *gtHeapWeight_a, medVal_a,\n                  medWeight_a, ltWeight_a, gtWeight_a, (*ltHeapValue_b)[i], (*ltHeapWeight_b)[i]);\n  }\n  for (int i = 0; i < int(gtHeapValue_b->size()); ++i) {\n    addToLevelSet(*ltHeapValue_a, *ltHeapWeight_a, *gtHeapValue_a, *gtHeapWeight_a, medVal_a,\n                  medWeight_a, ltWeight_a, gtWeight_a, (*gtHeapValue_b)[i], (*gtHeapWeight_b)[i]);\n  }\n  addToLevelSet(*ltHeapValue_a, *ltHeapWeight_a, *gtHeapValue_a, *gtHeapWeight_a, medVal_a,\n                medWeight_a, ltWeight_a, gtWeight_a, medVal_b, medWeight_b);\n}\n\n// [[Rcpp::export(name = \".pre_1d_l1\")]]\nstd::vector<double> pre_1d_l1(std::vector<double>& ycoords,\n                              std::vector<double>& weights, std::vector<double>& error, bool decreasing = false) {\n  if (decreasing) {\n    std::reverse(ycoords.begin(), ycoords.end());\n    std::reverse(weights.begin(), weights.end());\n  }\n\n  size_t data_size = ycoords.size();\n\n  std::vector< std::vector<double>* > ltHeapValues;\n  std::vector< std::vector<double>* > ltHeapWeights;\n  ltHeapValues.reserve(data_size);\n  ltHeapWeights.reserve(data_size);\n\n  std::vector< std::vector<double>* > gtHeapValues;\n  std::vector< std::vector<double>* > gtHeapWeights;\n  gtHeapValues.reserve(data_size);\n  gtHeapWeights.reserve(data_size);\n\n  std::vector<double> medValues;\n  std::vector<double> medWeights;\n  medValues.reserve(data_size);\n  medWeights.reserve(data_size);\n\n  std::vector<double> ltWeights;\n  std::vector<double> gtWeights;\n  ltWeights.reserve(data_size);\n  gtWeights.reserve(data_size);\n\n  std::vector<int> lefts;\n  lefts.reserve(data_size);\n\n  for (int i = 0; i < int(data_size); ++i) {\n    //initialize level set\n    ltHeapValues.push_back(0);\n    ltHeapWeights.push_back(0);\n    ltHeapValues[ltHeapValues.size() - 1] = new std::vector<double>;\n    ltHeapWeights[ltHeapWeights.size() - 1] = new std::vector<double>;\n    gtHeapValues.push_back(0);\n    gtHeapWeights.push_back(0);\n    gtHeapValues[gtHeapValues.size() - 1] = new std::vector<double>;\n    gtHeapWeights[gtHeapWeights.size() - 1] = new std::vector<double>;\n    medValues.push_back(ycoords[i]);\n    medWeights.push_back(weights[i]);\n    ltWeights.push_back(0);\n    gtWeights.push_back(0);\n    lefts.push_back(i);\n\n    int back = medValues.size() - 1;\n    int stBack = medValues.size() - 2; //second to back\n    while (back > 0 &&\n           medValues[back] <= medValues[stBack]) {\n\n      //merge the level sets\n\n\n      merge(ltHeapValues[stBack], ltHeapWeights[stBack], gtHeapValues[stBack],\n            gtHeapWeights[stBack], medValues[stBack], medWeights[stBack],\n                                                                ltWeights[stBack], gtWeights[stBack], ltHeapValues[back],\n                                                                                                                  ltHeapWeights[back], gtHeapValues[back], gtHeapWeights[back],\n                                                                                                                                                                        medValues[back], medWeights[back], ltWeights[back], gtWeights[back]);\n\n      delete ltHeapValues[back];\n      delete gtHeapValues[back];\n      delete ltHeapWeights[back];\n      delete gtHeapWeights[back];\n      ltHeapValues.pop_back();\n      ltHeapWeights.pop_back();\n      gtHeapValues.pop_back();\n      gtHeapWeights.pop_back();\n      medValues.pop_back();\n      medWeights.pop_back();\n      ltWeights.pop_back();\n      gtWeights.pop_back();\n      lefts.pop_back();\n\n      --back;\n      --stBack;\n    }\n\n  }\n  for (size_t i = 0; i < ltHeapValues.size(); ++i) {\n    delete ltHeapValues[i];\n    delete gtHeapValues[i];\n    delete ltHeapWeights[i];\n    delete gtHeapWeights[i];\n  }\n\n\n  std::vector<double> reg_data(data_size);\n\n  size_t curLSet = 0;\n  reg_data[0] = medValues[0];\n  error[0] = fabs(ycoords[0] - reg_data[0]);\n  for (int i = 1; i < int(data_size); ++i) {\n    if (int(curLSet) != int(medValues.size()) - 1 && lefts[curLSet + 1] == i) {\n      ++curLSet;\n    }\n    reg_data[i] = medValues[curLSet];\n    error[i] = error[i - 1] + fabs(ycoords[i] - reg_data[i]);\n  }\n\n  if (decreasing)\n    std::reverse(reg_data.begin(), reg_data.end());\n\n  return reg_data;\n}\n\n// [[Rcpp::export(name = \".uni_1d_l1\")]]\nstd::vector<double> uni_1d_l1(std::vector<double>& ycoords, std::vector<double>& weights) {\n  size_t size = ycoords.size();\n\n  std::vector<double> incErrors(size, 0);\n  std::vector<double> inc_reg = pre_1d_l1(ycoords, weights, incErrors);\n\n  //reverse std::vectors, then call prefix L1 on it again\n\n  std::reverse(ycoords.begin(), ycoords.end());\n  std::reverse(weights.begin(), weights.end());\n\n  std::vector<double> decErrors(size, 0);\n  std::vector<double> dec_reg = pre_1d_l1(ycoords, weights, decErrors);\n\n\n  //now find the best point for the mode, and copy the data used in\n  //the optimal unimodal regression into a new std::vector\n\n  //initialized to be the min of fully increasing or fully decreasing\n  double min_error = std::min(decErrors.back(), incErrors.back());\n  //if all are decreasing, set last increasing to be size to denote none\n  size_t last_increasing = min_error == incErrors.back() ? size - 1 : size;\n\n  //the prefix regression did the decreasing regression in reverse order,\n  //so instead of reversing the resulting std::vector we just go from the back\n  for (size_t i = 0; i < size - 2; ++i) {\n    double error_at_i = incErrors[i] + decErrors[size - 2 - i];\n    if (min_error > error_at_i) {\n      min_error = error_at_i;\n      last_increasing = i;\n    }\n  }\n\n  if (last_increasing == size) {\n    return dec_reg;\n  }\n  else if (last_increasing == size - 1) {\n    return inc_reg;\n  }\n\n  std::vector<double> unimodal(size);\n\n  for (size_t i = 0; i <= last_increasing; ++i) {\n    unimodal[i] = inc_reg[i];\n  }\n  for (size_t i = last_increasing + 1; i < size; ++i) { //double check bounds here***\n    unimodal[i] = dec_reg[size - 1 - i];\n  }\n\n  return unimodal;\n\n}\n\nclass region {\npublic:\n  std::vector <std::pair<int, std::pair<int, int> > > range;\n  int m, l, r;\n};\n\n// [[Rcpp::export(name = \".pre_1d_l2\")]]\nstd::vector<double> pre_1d_l2(std::vector<double> &y_vec, std::vector<double> &w_vec, bool decreasing = false) {\n  if (decreasing) {\n    std::reverse(y_vec.begin(), y_vec.end());\n    std::reverse(w_vec.begin(), w_vec.end());\n  }\n  size_t size = y_vec.size();\n  std::vector<double> y_new(size, 0);\n  std::vector<double> mean_vec(y_vec);\n  std::vector<double> sumwy_vec(y_vec);\n  std::vector<double> levelerr_vec(size, 0);\n  std::vector<double> sumwy2_vec(size, 0);\n  std::vector<double> sumw_vec(size, 1);\n  std::vector<size_t> left_vec(size, 0);\n  std::vector<size_t> right_vec(size, 0);\n\n  for (size_t i = 0; i < size; ++i) {\n    sumwy2_vec[i] = y_vec[i] * y_vec[i] * w_vec[i] * w_vec[i];\n    sumwy_vec[i] = y_vec[i] * w_vec[i];\n    sumw_vec[i] = w_vec[i];\n    left_vec[i] = i;\n    right_vec[i] = i;\n  }\n\n  size_t vec_back = 0;\n  for (size_t j = 0; j < size; ++j) {\n    bool flag = 0;\n    while (mean_vec[j] <= mean_vec[vec_back]) {\n      left_vec[j] = left_vec[vec_back];\n      sumwy_vec[j] = sumwy_vec[j] + sumwy_vec[vec_back];\n      sumwy2_vec[j] = sumwy2_vec[j] + sumwy2_vec[vec_back];\n      sumw_vec[j] = sumw_vec[j] + sumw_vec[vec_back];\n      mean_vec[j] = sumwy_vec[j] / sumw_vec[j];\n      levelerr_vec[j] = sumwy2_vec[j] - sumwy_vec[j] * sumwy_vec[j] / sumw_vec[j];\n      if (!vec_back) {\n        flag = 1;\n        break;\n      }\n      vec_back = vec_back - 1;\n    }\n    if (!flag)  vec_back = vec_back + 1;\n    left_vec[vec_back] = left_vec[j];\n    right_vec[vec_back] = right_vec[j];\n    sumwy_vec[vec_back] = sumwy_vec[j];\n    sumwy2_vec[vec_back] = sumwy2_vec[j];\n    sumw_vec[vec_back] = sumw_vec[j];\n    mean_vec[vec_back] = mean_vec[j];\n    levelerr_vec[vec_back] = levelerr_vec[j];\n  }\n  if (levelerr_vec[0] > 0) {}\n  for (size_t k = 0; k <= vec_back; ++k) {\n    for (size_t l = left_vec[k]; l <= right_vec[k]; ++l) {\n      y_new[l] = mean_vec[k];\n    }\n  }\n  if (decreasing) {\n    std::reverse(y_new.begin(), y_new.end());\n  }\n  return y_new;\n}\n\n\n\n\n// [[Rcpp::export(name = \".uni_1d_l2\")]]\nstd::vector<double> uni_1d_l2(std::vector<double>& y_vec, std::vector<double>& w_vec) {\n  int size = y_vec.size();\n  std::vector<double> error((size + 1), 0);\n  std::vector<double> err_asc(size, 0);\n  std::vector<double> err_dec(size, 0);\n  std::vector<double> y_new(size, 0);\n\n  //ascending part\n  std::vector<double> mean_vec(y_vec);\n  std::vector<double> sumwy_vec(y_vec);\n  std::vector<double> levelerr_vec(size, 0);\n  std::vector<double> sumwy2_vec(size, 0);\n  std::vector<double> sumw_vec(size, 0);\n\n  for (int i = 0; i < size; ++i) {\n\n\n    sumwy2_vec[i] = y_vec[i] * y_vec[i] * w_vec[i] * w_vec[i];\n    sumwy_vec[i] = y_vec[i] * w_vec[i];\n    sumw_vec[i] = w_vec[i];\n  }\n  int vec_back = 0;\n  err_asc[0] = 0;\n  for (int j = 1; j < size; ++j) {\n    err_asc[j] = err_asc[j - 1];\n    while (vec_back >= 0 && mean_vec[j] <= mean_vec[vec_back]) {\n      sumwy_vec[j] = sumwy_vec[j] + sumwy_vec[vec_back];\n      sumwy2_vec[j] = sumwy2_vec[j] + sumwy2_vec[vec_back];\n      sumw_vec[j] = sumw_vec[j] + sumw_vec[vec_back];\n      mean_vec[j] = sumwy_vec[j] / sumw_vec[j];\n      levelerr_vec[j] = sumwy2_vec[j] - sumwy_vec[j] * sumwy_vec[j] / sumw_vec[j];\n      err_asc[j] = err_asc[j] - levelerr_vec[vec_back];\n      vec_back = vec_back - 1;\n    }\n    vec_back = vec_back + 1;\n    sumwy_vec[vec_back] = sumwy_vec[j];\n    sumwy2_vec[vec_back] = sumwy2_vec[j];\n    sumw_vec[vec_back] = sumw_vec[j];\n    mean_vec[vec_back] = mean_vec[j];\n    levelerr_vec[vec_back] = levelerr_vec[j];\n    err_asc[j] = err_asc[j] + levelerr_vec[vec_back];\n  }\n\n  //decending part\n  for (int i = 0; i < size; ++i) {\n    mean_vec[i] = y_vec[size - i - 1];\n    levelerr_vec[i] = 0;\n    sumwy2_vec[i] = y_vec[size - i - 1] * y_vec[size - i - 1] * w_vec[size - i - 1] * w_vec[size - i - 1];\n    sumwy_vec[i] = y_vec[size - i - 1] * w_vec[size - i - 1];\n    sumw_vec[i] = w_vec[size - i - 1];\n  }\n\n  vec_back = 0;\n  err_dec[0] = 0;\n  for (int j = 1; j < size; ++j) {\n    err_dec[j] = err_dec[j - 1];\n    while (vec_back >= 0 && mean_vec[j] <= mean_vec[vec_back]) {\n      sumwy_vec[j] = sumwy_vec[j] + sumwy_vec[vec_back];\n      sumwy2_vec[j] = sumwy2_vec[j] + sumwy2_vec[vec_back];\n      sumw_vec[j] = sumw_vec[j] + sumw_vec[vec_back];\n      mean_vec[j] = sumwy_vec[j] / sumw_vec[j];\n      levelerr_vec[j] = sumwy2_vec[j] - sumwy_vec[j] * sumwy_vec[j] / sumw_vec[j];\n      err_dec[j] = err_dec[j] - levelerr_vec[vec_back];\n      vec_back = vec_back - 1;\n    }\n    vec_back = vec_back + 1;\n    sumwy_vec[vec_back] = sumwy_vec[j];\n    sumwy2_vec[vec_back] = sumwy2_vec[j];\n    sumw_vec[vec_back] = sumw_vec[j];\n    mean_vec[vec_back] = mean_vec[j];\n    levelerr_vec[vec_back] = levelerr_vec[j];\n    err_dec[j] = err_dec[j] + levelerr_vec[vec_back];\n  }\n  //find minimum error\n  error[0] = err_dec[size - 1];\n  error[size] = err_asc[size - 1];\n  for (int i = 1; i < size; ++i) {\n    error[i] = err_asc[i - 1] + err_dec[size - i];\n  }\n\n  int pos_min = 0;\n  for (int i = 0; i < size; ++i) {\n    if (error[i] < error[pos_min]) {\n      pos_min = i;\n    }\n  }\n\n\n  std::vector<double> left_vec(y_vec.size(), 0);\n  std::vector<double> right_vec(y_vec.size(), 0);\n  for (int i = 0; i < int(y_vec.size()); ++i) {\n    left_vec[i] = i;\n    right_vec[i] = i;\n  }\n\n\n  //regression on ascending part\n  if (pos_min != 0) {\n\n    for (int i = 0; i < pos_min; ++i) {\n      mean_vec[i] = y_vec[i];\n      sumwy_vec[i] = y_vec[i] * w_vec[i];\n      sumw_vec[i] = w_vec[i];\n    }\n\n    vec_back = 0;\n    for (int j = 1; j < pos_min; ++j) {\n      while (vec_back >= 0 && mean_vec[j] <= mean_vec[vec_back]) {\n        left_vec[j] = left_vec[vec_back];\n        sumwy_vec[j] = sumwy_vec[j] + sumwy_vec[vec_back];\n        sumw_vec[j] = sumw_vec[j] + sumw_vec[vec_back];\n        mean_vec[j] = sumwy_vec[j] / sumw_vec[j];\n        vec_back = vec_back - 1;\n      }\n      vec_back = vec_back + 1;\n      left_vec[vec_back] = left_vec[j];\n      right_vec[vec_back] = right_vec[j];\n      sumwy_vec[vec_back] = sumwy_vec[j];\n      sumw_vec[vec_back] = sumw_vec[j];\n      mean_vec[vec_back] = mean_vec[j];\n    }\n\n    for (int k = 0; k <= vec_back; ++k) {\n      for (int l = (int)left_vec[k]; l <= (int)right_vec[k]; ++l) {\n        y_new[l] = mean_vec[k];\n      }\n    }\n\n  }\n\n  //regression on decending part\n  if (pos_min != size) {\n\n    for (int i = 0; i < (size - pos_min); ++i) {\n      mean_vec[i] = y_vec[size - i - 1];\n      left_vec[i] = i;\n      right_vec[i] = i;\n      sumwy_vec[i] = y_vec[size - i - 1] * w_vec[size - i - 1];\n      sumw_vec[i] = w_vec[size - i - 1];\n    }\n\n    vec_back = 0;\n    for (int j = 1; j < (size - pos_min); ++j) {\n      while (vec_back >= 0 && mean_vec[j] <= mean_vec[vec_back]) {\n        left_vec[j] = left_vec[vec_back];\n        sumwy_vec[j] = sumwy_vec[j] + sumwy_vec[vec_back];\n        sumw_vec[j] = sumw_vec[j] + sumw_vec[vec_back];\n        mean_vec[j] = sumwy_vec[j] / sumw_vec[j];\n        vec_back = vec_back - 1;\n      }\n      vec_back = vec_back + 1;\n      left_vec[vec_back] = left_vec[j];\n      right_vec[vec_back] = right_vec[j];\n      sumwy_vec[vec_back] = sumwy_vec[j];\n      sumw_vec[vec_back] = sumw_vec[j];\n      mean_vec[vec_back] = mean_vec[j];\n    }\n\n    for (int k = 0; k <= vec_back; ++k) {\n      for (int l = (int)left_vec[k]; l <= (int)right_vec[k]; ++l) {\n        y_new[size - l - 1] = mean_vec[k];\n      }\n    }\n  }\n\n\n  return y_new;\n\n}\n\n\n\n\n// [[Rcpp::export(name = \".pre_1d_linf\")]]\nstd::vector<double> pre_1d_linf(std::vector<double>& y, bool decreasing = false) {\n\n  int size = (int)y.size();\n\n\n\n  std::vector<double> error(size + 1, 0), y_new(size, 0), mean(size + 1, 0), maxy(size + 1, 0), miny(size + 1, 0), y_vec(y);\n  std::vector<int> left(size + 1, 0);\n\n\n  if (decreasing) {\n    std::reverse(y_vec.begin(), y_vec.end());\n  }\n\n  //cout << error.size() << endl;\n\n  mean[0] = std::numeric_limits<double>::min();\n\n  //regression\n  for (int i = 1; i <= size; ++i) {\n    maxy[i] = y_vec[i - 1];\n    miny[i] = y_vec[i - 1];\n    mean[i] = y_vec[i - 1];\n    left[i] = i;\n\n    while ((left[i] - 1) > 0 && mean[i] <= mean[left[i] - 1]) {\n\n      int j = left[i] - 1;\n      miny[i] = miny[i]<miny[j] ? miny[i] : miny[j];\n      maxy[i] = maxy[i]>maxy[j] ? maxy[i] : maxy[j];\n      mean[i] = (miny[i] + maxy[i]) / double(2);\n      left[i] = left[j];\n    }\n    double levelerror = (maxy[i] - miny[i]) / double(2);\n    error[i] = levelerror>error[left[i] - 1] ? levelerror : error[left[i] - 1];\n  }\n\n  //recover means\n  for (int i = size; i > 0;) {\n    if (left[i] != i) {\n      for (int j = left[i]; j <= i; ++j) {\n        y_new[j - 1] = mean[i];\n      }\n      i = left[i] - 1;\n    }\n\n    else {\n      y_new[i - 1] = mean[i];\n      --i;\n    }\n  }\n\n  if (decreasing) {\n    std::reverse(y_new.begin(), y_new.end());\n  }\n\n  return y_new;\n}\n\n\n\n// [[Rcpp::export(name = \".uni_1d_linf\")]]\nstd::vector<double> uni_1d_linf(std::vector<double>& y_vec) {\n\n  int size = (int)y_vec.size();\n  std::vector<double> error(size + 1, 0), error_asc(size + 1, 0), error_dec(size + 1, 0), y_new(size, 0), mean_asc(size + 1, 0), mean_dec(size + 1, 0), maxy(size + 1, 0), miny(size + 1, 0), y(size + 1, 0), y_rev(size + 1, 0);\n  std::vector<int> left_asc(size + 1, 0), left_dec(size + 1, 0);\n\n  for (int i = 1; i <= size; ++i) {\n    y[i] = y_vec[i - 1];\n  }\n\n  //reversed\n  for (int i = 1; i <= size; ++i) {\n    y_rev[i] = y_vec[size - i];\n  }\n\n  mean_asc[0] = std::numeric_limits<double>::min();\n  mean_dec[0] = std::numeric_limits<double>::min();\n\n\n  //error calculation asc\n  for (int i = 1; i <= size; ++i) {\n\n    //setting the default max min mean left as the point itself\n    maxy[i] = y[i];\n    miny[i] = y[i];\n    mean_asc[i] = y[i];\n    left_asc[i] = i;\n\n    //while the current point has mean less or equal to prev level, then keep merging\n    // until the whole current level set\n    while ((left_asc[i] - 1) > 0 && mean_asc[i] <= mean_asc[left_asc[i] - 1]) {\n\n      int j = left_asc[i] - 1;\n\n      //min{prev_level, current_point}, max{prev_level, current_point}\n      miny[i] = miny[i]<miny[j] ? miny[i] : miny[j];\n      maxy[i] = maxy[i]>maxy[j] ? maxy[i] : maxy[j];\n\n      //the mean only keeps to the current point, even if it's prev level is lowered\n      // so the stats in any point before will not change.\n      // i.e. 1,3,4 and add 2.\n      // 1,3,4 has stats same as themselves. 2 will have mean=3, left=position at 3, max=4, min=2\n      // so 2 level sets are 1 and 3,4,2 where information of the later is kept by point at 2\n      mean_asc[i] = (miny[i] + maxy[i]) / double(2);\n      left_asc[i] = left_asc[j];\n    }\n\n    //error for new point, nonzero if it is lower than prev\n    double levelerror = (maxy[i] - miny[i]) / double(2);\n    error_asc[i] = levelerror>error[left_asc[i] - 1] ? levelerror : error_asc[left_asc[i] - 1];\n  }\n\n  //error calculation asc\n  for (int i = 1; i <= size; ++i) {\n    maxy[i] = y_rev[i];\n    miny[i] = y_rev[i];\n    mean_dec[i] = y_rev[i];\n    left_dec[i] = i;\n\n    while ((left_dec[i] - 1) > 0 && mean_dec[i] <= mean_dec[left_dec[i] - 1]) {\n\n      int j = left_dec[i] - 1;\n      miny[i] = miny[i]<miny[j] ? miny[i] : miny[j];\n      maxy[i] = maxy[i]>maxy[j] ? maxy[i] : maxy[j];\n      mean_dec[i] = (miny[i] + maxy[i]) / double(2);\n      left_dec[i] = left_dec[j];\n    }\n    double levelerror = (maxy[i] - miny[i]) / double(2);\n    error_dec[i] = levelerror>error[left_dec[i] - 1] ? levelerror : error_dec[left_dec[i] - 1];\n  }\n\n  //diving to 2 halves based on minimum error. points_count+1 possibilities\n  // i.e. 1342 into dec1324, inc1+dec342,inc13+dec42, inc134+dec2, asc1342\n  error[0] = error_dec[size];\n  double min = error[0];\n  int pos_min = 0;\n\n  error[size] = error_asc[size];\n  for (int i = 1; i < size; ++i) {\n    error[i] = error_asc[i] + error_dec[size - i];\n  }\n\n  for (int i = 1; i <= size; ++i) {\n    if (min > error[i]) {\n      pos_min = i;\n      min = error[i];\n    }\n  }\n\n  std::vector<double> y_new_aux(size - pos_min, 0);\n  //recover means\n  //if the result is not straight descend\n  // if it is then goes to the next if condition\n  if (pos_min != 0) {\n    for (int i = pos_min; i > 0;) {\n      if (left_asc[i] != i) {\n        for (int j = left_asc[i]; j <= i; ++j) {\n\n          //y_new has the input y_vec size\n          y_new[j - 1] = mean_asc[i];\n        }\n        i = left_asc[i] - 1;\n      }\n\n      else {\n        y_new[i - 1] = mean_asc[i];\n        --i;\n      }\n    }\n  }\n\n  //if the result is not straight ascend\n  if (pos_min != size) {\n    for (int i = size - pos_min; i > 0;) {\n      if (left_dec[i] != i) {\n        for (int j = left_dec[i]; j <= i; ++j) {\n          y_new_aux[j - 1] = mean_dec[i];\n        }\n        i = left_dec[i] - 1;\n      }\n\n      else {\n        y_new_aux[i - 1] = mean_dec[i];\n        --i;\n      }\n    }\n  }\n\n  //concatenate\n  for (int i = 0; i < size - pos_min; ++i) {\n    y_new[pos_min + i] = y_new_aux[size - pos_min - 1 - i];\n  }\n\n  return y_new;\n}\n\n\n\n// [[Rcpp::export(name = \".pre_2d_l1_inc\")]]\nNumericMatrix pre_2d_l1_inc(NumericMatrix& w, NumericMatrix& data) {\n\n  int row_size = int(data.nrow()), col_size = int(data.ncol());\n\n  //sorted reference\n  std::vector <double> sorted_data(row_size*col_size);\n  for (int i = 0; i < row_size; ++i) {\n    for (int j = 0; j < col_size; ++j) {\n      sorted_data[i*col_size + j]=data(i,j);\n    }\n  }\n  sort(sorted_data.begin(), sorted_data.end());\n\n  //output matrix\n  NumericMatrix out(row_size,col_size );\n\n  //start point\n  region* temp = new region;\n  temp->range.reserve(row_size);\n  for (int i = 0; i < row_size; ++i) {\n    temp->range.push_back(make_pair(i, std::make_pair(0, col_size - 1)));\n  }\n  temp->l = 0;\n  temp->r = row_size*col_size - 1;\n  temp->m = ((temp->l + temp->r + 1) / 2);\n\n  //queue for recursion\n  std::deque<region*> collection;\n  collection.push_back(temp);\n\n  //auxiliary matrices that record actual matrix positions\n  std::vector <std::vector<double> > s;\n  std::vector <std::vector<int> > t;\n  s.resize(row_size);\n  t.resize(row_size);\n\nfor(int i=0;i<row_size;++i){\n  s[i].resize(col_size + 1, 0);\n  t[i].resize(col_size + 1, -1);\n}\n  //m1, m2 is index\n  int m1 = 0, m2 = 0;\n\n  while (!collection.empty()) {\n    region* cur = collection[0];\n    collection.pop_front();\n\n    //indicate if cur needed to be deleted\n    bool good_to_delete = false;\n\n    //if only one small grid, or l==r, then fill in output matrix\n    if ((cur->range.size() == 1 && cur->range[0].second.second == cur->range[0].second.first)||cur->l>=cur->r) {\n      for (int i = 0; i < int(cur->range.size()); ++i) {\n        int row = cur->range[i].first;\n        int start_col = cur->range[i].second.first, end_col = cur->range[i].second.second;\n        for (int col = start_col; col <= end_col; ++col) {\n\n          out(row,col) = sorted_data[cur->m];\n        }\n      }\n      good_to_delete = true;\n    }\n\n    else {\n      m2 = (cur->l + cur->r + 1) / 2;\n      m1 = m2 - 1;\n\n      //calculate error\n      for (int pos = 0; pos < int(cur->range.size()); ++pos) {\n        int row = cur->range[pos].first, start_col = cur->range[pos].second.first, end_col = cur->range[pos].second.second;\n        double rowsum = 0;\n        std::vector<double> r(end_col - start_col + 2, 0), l(end_col - start_col + 2, 0);\n\n        //calculate r\n        for (int col = start_col, i = 1; col <= end_col; ++col, ++i) {\n          rowsum += w(row,col) * fabs(sorted_data[m1] - data(row,col));\n          r[i] = rowsum;\n        }\n\n        rowsum = 0;\n\n        //calculate l\n        for (int col = end_col, i = end_col - start_col; col >= start_col; --col, --i) {\n          rowsum += w(row,col) * fabs(sorted_data[m2] - data(row,col));\n          l[i] = rowsum;\n        }\n\n        //fill in s with r. If not first row, then also add min error from above right\n        for (int col = start_col, i = 0; col <= end_col + 1; ++col, ++i) {\n          s[row][col] = r[i] + l[i];\n\n          //second row and so on\n          if (pos != 0) {\n            if (t[cur->range[pos - 1].first][col] == -1) {\n              s[row][col] += s[cur->range[pos - 1].first][t[cur->range[pos - 1].first][cur->range[pos - 1].second.first]];\n            }\n\n            else s[row][col] += s[cur->range[pos - 1].first][t[cur->range[pos - 1].first][col]];\n          }\n        }\n\n        //find t matrix for current row\n        t[row][end_col + 1] = end_col + 1;\n        for (int col = end_col; col >= start_col; --col) {\n          if (s[row][col]<s[row][t[row][col + 1]]) t[row][col] = col;\n          else t[row][col] = t[row][col + 1];\n        }\n\n      }\n\n\n      //backtrace\n      int cur_row = cur->range.back().first, cur_col = t[cur_row][cur->range.back().second.first];\n      std::vector<int> trace;\n      trace.reserve(cur->range.size());\n      trace.push_back(cur_col);\n\n      //they indicate if there are splits\n      bool all_m1 = cur_col == cur->range.back().second.second+1, all_m2 = cur_col == cur->range.back().second.first;\n      for (int i = int(cur->range.size()) - 2; i >= 0; --i) {\n        cur_row = cur->range[i].first;\n\n        //if no data at top, pick the min for whole row\n        if (t[cur_row][cur_col] == -1)\n          cur_col = t[cur_row][cur->range[i].second.first];\n        else cur_col = t[cur_row][cur_col];\n        trace.push_back(cur_col);\n        if (cur_col != cur->range[i].second.second+1)  all_m1 = false;\n        if (cur_col != cur->range[i].second.first)  all_m2 = false;\n      }\n\n      //if all are one m and no more m1, m2 retrieving at that direction, then fill in output\n      if ((all_m1&&cur->l == m1)||( all_m2&&cur->r == m2)) {\n        for (int i = 0; i < int(cur->range.size()); ++i) {\n          int row = cur->range[i].first;\n          int start_col = cur->range[i].second.first, end_col = cur->range[i].second.second;\n          for (int col = start_col; col <= end_col; ++col) {\n            out(row,col) = all_m1? sorted_data[m1]: sorted_data[m2];\n          }\n        }\n        good_to_delete = true;\n      }\n\n      //else take new m1, m2 and add in this cur back\n      else if (all_m1) {\n        cur->m= cur->r = m1;\n        collection.push_back(cur);\n      }\n      else if (all_m2) {\n        cur->l = m2;\n        collection.push_back(cur);\n      }\n\n      //split\n      else {\n        //a is left, b is right\n        region* a = new region; a->range.reserve(cur->range.size());\n        region* b = new region; b->range.reserve(cur->range.size());\n        for (int i = 0; i <= int(cur->range.size()) - 1; ++i) {\n\n          //if all m2\n          if (trace[cur->range.size() - i - 1] == cur->range[i].second.first) {\n            b->range.push_back(std::make_pair(cur->range[i].first, std::make_pair(cur->range[i].second.first, cur->range[i].second.second)));\n          }\n\n          //otherwise\n          else {\n            a->range.push_back(std::make_pair(cur->range[i].first, std::make_pair(cur->range[i].second.first, trace[cur->range.size() - i - 1] - 1)));\n            if (trace[cur->range.size() - i - 1]  <= cur->range[i].second.second) {\n              b->range.push_back(std::make_pair(cur->range[i].first, std::make_pair(trace[cur->range.size() - i - 1], cur->range[i].second.second)));\n            }\n          }\n        }\n\n        //the right of left region is m1, vice verse\n        a->l = cur->l;\n        a->m = a->r = m1;\n        b->r = cur->r;\n        b->m = b->l = m2;\n        collection.push_back(a);\n        collection.push_back(b);\n        good_to_delete = true;\n      }\n    }\n\n    //recover s and t\n    for (int i = 0; i < int(cur->range.size()); ++i) {\n      int row = cur->range[i].first;\n      int start_col = cur->range[i].second.first, end_col = cur->range[i].second.second;\n      for (int col = start_col; col <= end_col + 1; ++col) {\n        s[row][col] = 0;\n        t[row][col] = -1;\n      }\n    }\n    if(good_to_delete) delete cur;\n  }\n  return out;\n}\n\n\n\n// [[Rcpp::export(name = \".pre_2d_l1_inc\")]]\nNumericMatrix pre_2d_l2_inc(NumericMatrix & w, NumericMatrix &data) {\n\n\n  int row_size = int(data.nrow()), col_size = int(data.ncol());\n\n  //output matrix\n  NumericMatrix out(row_size, col_size);\n\n  //start point\n  region* temp = new region;\n  temp->range.reserve(row_size);\n  for (int i = 0; i < row_size; ++i) {\n    temp->range.push_back(std::make_pair(i, std::make_pair(0, col_size - 1)));\n  }\n\n  //queue for recursion\n  std::deque<region*> collection;\n  collection.push_back(temp);\n\n  //auxiliary matrices that record actual matrix positions\n  std::vector <std::vector<double> > s;\n  std::vector <std::vector<int> > t;\n  s.resize(row_size);\n  t.resize(row_size);\n  for (int i = 0; i < int(s.size()); ++i) {\n    s[i].resize(col_size, 0);\n    t[i].resize(col_size, -1);\n  }\n\n  while (!collection.empty()) {\n    region* cur = collection[0];\n    collection.pop_front();\n    double x;\n    double sumw = 0;\n    double sum = 0;\n\n    for (int j = 0; j < int(cur->range.size()); ++j) {\n      std::pair<int, std::pair<int, int> > i = cur->range[j];\n\n      int row = i.first;\n      int start_col = i.second.first, end_col = i.second.second;\n      for (int col = start_col; col <= end_col; ++col) {\n        sumw += w(row,col);\n        sum += (w(row,col) * data(row,col));\n\n      }\n    }\n    x = sum / (double)sumw;\n    //weighted_avg(*cur, w, data,x);\n\n    //min_index is the index in the region std::vector where smallest happen\n    int min_row = 0, min_col = 0, min_index = 0;\n\n    //compute s and t and min_row and min_col\n    for (int i = 0; i < int(cur->range.size()); ++i) {\n\n      int row = cur->range[i].first;\n      int start_col = cur->range[i].second.first, end_col = cur->range[i].second.second;\n      double rowsum = 0;\n\n      //fill in s. If not first row, then also add min error from above right\n      for (int col = start_col; col <= end_col; ++col) {\n\n        rowsum += w(row,col) * (data(row,col) - x);\n        s[row][col] = rowsum;\n\n        //second row and so on\n        if (i != 0) {\n          if (t[cur->range[i - 1].first][col] == -1) {\n            s[row][col] += s[cur->range[i - 1].first][t[cur->range[i - 1].first][cur->range[i - 1].second.first]];\n          }\n\n          else s[row][col] += s[cur->range[i - 1].first][t[cur->range[i - 1].first][col]];\n        }\n      }\n\n      //find t matrix for current row\n      t[row][end_col] = end_col;\n      for (int col = end_col - 1; col >= start_col; --col) {\n        if (s[row][col]<s[row][t[row][col + 1]]) t[row][col] = col;\n        else t[row][col] = t[row][col + 1];\n      }\n\n      //find min_col and min_row\n      // for first row min_col is t[row][start_col]\n      if (i == 0) {\n        min_row = row;\n        min_col = t[row][start_col];\n      }\n\n      //for further rows min\n      else {\n        if (s[row][t[row][start_col]] <= s[min_row][min_col]) {\n          min_row = row;\n          min_col = t[row][start_col];\n          min_index = i;\n        }\n      }\n    }\n\n    if (cur->range.size() == 1) {\n      //first_row_situation(cur, collection, t, out, x);\n      int row = cur->range[0].first;\n      int start_col = cur->range[0].second.first, end_col = cur->range[0].second.second;\n\n      //check if k==m\n      if (t[row][start_col] == end_col) {\n        for (int col = start_col; col <= end_col; ++col) {\n          out(row,col) = x;\n        }\n      }\n\n      else {\n        region* a = new region;\n        region* b = new region;\n        a->range.push_back(std::make_pair(row, std::make_pair(start_col, t[row][start_col])));\n        b->range.push_back(std::make_pair(row, std::make_pair(t[row][start_col] + 1, end_col)));\n        collection.push_back(a);\n        collection.push_back(b);\n      }\n\n    }\n\n    else {\n      //changed\n      //if no negative entry, treat the region as a single levelset\n      if (s[min_row][min_col] >= 0) {\n\n        for (int j = 0; j < int(cur->range.size()); ++j) {\n          std::pair<int, std::pair<int, int> > i = cur->range[j];\n          for (int col = i.second.first; col <= i.second.second; ++col) {\n            out(i.first,col) = x;\n          }\n        }\n      }\n\n      else {\n        int cur_row = min_row, cur_col = min_col;\n        std::vector<int> trace;\n        trace.reserve(min_index + 1);\n        trace.push_back(cur_col);\n\n        //backtrace\n        for (int i = min_index - 1; i >= 0; --i) {\n          cur_row = cur->range[i].first;\n          if (t[cur_row][cur_col] == -1) {\n            cur_col = t[cur_row][cur->range[i].second.first];\n          }\n          else cur_col = t[cur_row][cur_col];\n          trace.push_back(cur_col);\n        }\n\n        //a is left, b is right, a is never empty\n        region* a = new region;\n        region* b = new region;\n        a->range.resize(0);\n        b->range.resize(0);\n        a->range.reserve(cur->range.size());\n        b->range.reserve(cur->range.size());\n        for (int i = 0; i <= min_index; ++i) {\n          a->range.push_back(std::make_pair(cur->range[i].first, std::make_pair(cur->range[i].second.first, trace[min_index - i])));\n          if (trace[min_index - i] + 1 <= cur->range[i].second.second) {\n            b->range.push_back(std::make_pair(cur->range[i].first, std::make_pair(trace[min_index - i] + 1, cur->range[i].second.second)));\n          }\n        }\n\n        //if the left subregion contain the region's last row\n        if (min_index == int(cur->range.size() - 1)) {\n\n          //if left subregion is the entire region\n          if (b->range.empty()) {\n            delete a;\n            delete b;\n\n            for (int j = 0; j < int(cur->range.size()); ++j) {\n              std::pair<int, std::pair<int, int> > i = cur->range[j];\n              for (int col = i.second.first; col <= i.second.second; ++col) {\n                out(i.first,col) = x;\n              }\n            }\n          }\n          else {\n            collection.push_back(a);\n            collection.push_back(b);\n          }\n\n        }\n        else {\n          //still few rows beneath left region\n          collection.push_back(a);\n\n          for (int i = min_index + 1; i < int(cur->range.size()); ++i) {\n            b->range.push_back(std::make_pair(cur->range[i].first, std::make_pair(cur->range[i].second.first, cur->range[i].second.second)));\n          }\n          collection.push_back(b);\n        }\n      }\n    }\n\n\n    //recover s and t\n    for (int i = 0; i < int(cur->range.size()); ++i) {\n      int row = cur->range[i].first;\n      int start_col = cur->range[i].second.first, end_col = cur->range[i].second.second;\n      for (int col = start_col; col <= end_col; ++col) {\n        s[row][col] = 0;\n        t[row][col] = -1;\n      }\n    }\n    delete cur;\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nstd::vector<double> iso_1d(std::vector<double>& y_vec, std::vector<double>& w_vec, int metric,\n                           bool unimodal = false, bool decreasing = false) {\n\n  if (y_vec.size() == 0) stop(\"Empty data\");\n  if (w_vec.empty()) w_vec.resize(y_vec.size(), 1);\n  if (w_vec.size() != y_vec.size()) stop(\"Data and weight have different number of entries\");\n  for (int i = 0; i < int(w_vec.size()); ++i) {\n    if (w_vec[i]<0) {\n      stop(\"Negative weight detected\");\n    }\n  }\n  std::vector<double> out;\n  if (metric == 1) {\n    std::vector<double> error;\n    error.resize(y_vec.size(), 0);\n    if (!unimodal) {\n      if (decreasing) {\n        out = pre_1d_l1(y_vec, w_vec, error, true);\n      }\n      else {\n        out = pre_1d_l1(y_vec, w_vec, error);\n      }\n    }\n    else {\n      out = uni_1d_l1(y_vec, w_vec);\n    }\n  }\n  else if (metric == 2) {\n    if (!unimodal) {\n      if (decreasing) {\n        out = pre_1d_l2(y_vec, w_vec, true);\n      }\n      else {\n        out = pre_1d_l2(y_vec, w_vec);\n      }\n    }\n    else {\n      out = uni_1d_l2(y_vec, w_vec);\n    }\n  }\n  else if (metric == 3) {\n    if (!unimodal) {\n      if (decreasing) {\n        out = pre_1d_linf(y_vec, true);\n      }\n      else {\n        out = pre_1d_linf(y_vec);\n      }\n    }\n    else {\n      out = uni_1d_linf(y_vec);\n    }\n  }\n  else {\n    stop(\"Metric does not exist\");\n  }\n  return out;\n}\n\n// [[Rcpp::export]]\nNumericMatrix iso_2d_increasing(NumericMatrix& y_vec,\n                                NumericMatrix& w_vec, int metric\n) {\n\n  //error check\n  if (y_vec.nrow() == 0 || y_vec.ncol()== 0) stop(\"Empty data\");\n  if (w_vec.nrow() == 0 || w_vec.ncol()== 0) {\n    w_vec=NumericMatrix(y_vec.nrow(),y_vec.ncol());\n  }\n\n  if (w_vec.nrow() != y_vec.nrow()) stop(\"Data and weight have different number of rows\");\n  if (w_vec.ncol() != y_vec.ncol()) stop(\"Data and weight have different number of columns\");\n\n  for (int i = 0; i < w_vec.nrow(); ++i) {\n    for (int j = 0; j < w_vec.ncol(); ++j) {\n      if (w_vec(i,j) < 0) {\n        stop(\"Negative weight detected\");\n      }\n    }\n  }\n\n  NumericMatrix out;\n  if (metric == 1) {\n    out = pre_2d_l1_inc(w_vec, y_vec);\n    return out;\n  }\n  else if (metric == 2) {\n    out = pre_2d_l2_inc(w_vec, y_vec);\n    return out;\n  }\n  else {\n    stop(\"metric does not exist\");\n  }\n\n\n\n}\n",
    "created" : 1504585527491.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4268819762",
    "id" : "57D85A1A",
    "lastKnownWriteTime" : 1504585590,
    "last_content_update" : 1504585590652,
    "path" : "C:/Users/Chenkai Sun/Desktop/IsoReg/IsoReg/src/isofinal.cpp",
    "project_path" : "src/isofinal.cpp",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}